package com.github.machosmurf.exploitdbwatchdog;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;


/**
 * Parses exploit DB files
 */
@Component
public class Exploitparser {
    private final ExploitRepository exploitRepository;
    private ArrayList<RemoteExploitCSV> filesToDownload;

    @Autowired
    public Exploitparser(ExploitRepository exploitRepository){
        this.exploitRepository = exploitRepository;
        filesToDownload = new ArrayList<>();
        filesToDownload.add(new RemoteExploitCSV("https://raw.githubusercontent.com/offensive-security/exploit-database/master/files_exploits.csv", "files_exploits.csv"));
        filesToDownload.add(new RemoteExploitCSV("https://raw.githubusercontent.com/offensive-security/exploit-database/master/files_shellcodes.csv", "files_shellcodes.csv"));
        filesToDownload.add(new RemoteExploitCSV("https://raw.githubusercontent.com/offensive-security/exploit-database-papers/master/files_papers.csv", "files_papers.csv"));
    }

    //TODO: Re-enable
    //@Scheduled(fixedDelay = 3600000)
    private void checkExploitDatabases(){
        downloadFiles();
        parseFiles();
        removeFiles();
        generateStats();
    }

    private void generateStats() {
        //TODO: Generate Stats for easy search and a clean overview
        new DatabaseStats(exploitRepository);
    }

    private void downloadFiles() {
        for(RemoteExploitCSV remoteFile : filesToDownload){
            try{
                URL website = new URL(remoteFile.getFullURL());
                try (InputStream in = website.openStream()) {
                    System.out.println("Downloading " + remoteFile.getFilename());
                    Files.copy(in, Paths.get(remoteFile.getFilename()), StandardCopyOption.REPLACE_EXISTING);
                    in.close();
                }
            }
            catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Finished downloading csv's");
    }

    private void parseFiles() {
        System.out.println("Starting parsing of csv's");

        for(RemoteExploitCSV fileToParse : filesToDownload){
            Reader in = null;
            try{
                in = new FileReader(fileToParse.getFilename());
                Iterable<CSVRecord> records = CSVFormat.EXCEL.withHeader().withAllowMissingColumnNames().parse(in);
                SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
                for(CSVRecord record : records){
                    int id = Integer.parseInt(record.get("id"));
                    String file = record.get("file");
                    String description = record.get("description");
                    Date date = dateFormat.parse(record.get("date"));
                    String author = record.get("author");
                    String type = record.get("type");
                    String platform = record.get("platform");

                    Exploit exploit = null;

                    switch (fileToParse.getFilename()){
                        case "files_exploits.csv":
                            int port = -1;
                            if (record.get("port") != null){
                                String p = record.get("port");
                                if ((!p.equals("") && (p.matches("[0-9]+")))){
                                    port = Integer.parseInt(record.get("port"));
                                }
                            }
                            if (!exploitRepository.exists(id)){
                                exploit = new Exploit(id, file, description, date, author, type, platform, port);
                            }
                            break;
                        case "files_papers.csv":
                            String language = "";
                            if (record.get("language") != null){
                                language = record.get("language");
                            }
                            if (!exploitRepository.exists(id)){
                                exploit = new Exploit(id, file, description, date, author, type, platform, language);
                            }
                            break;
                        case "files_shellcodes.csv":
                            if (!exploitRepository.exists(id)){
                                exploit = new Exploit(id, file, description, date, author, type, platform);
                            }
                            break;
                    }

                    //add exploit to database
                    if (exploit != null){
                        Exploit result = exploitRepository.save(exploit);
                        if (result.equals(exploit)){
                            System.out.println("Added exploit id: " + exploit.getExploitID());
                        }
                    }
                }
            }
            catch (Exception e){
                System.out.println(e);
            }
            finally{
                if (in != null){
                    try {
                        in.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }

        System.out.println("Done parsing csv's");
    }

    private void removeFiles() {
        System.out.println("Removing csv's");
        //try to remove local copies
        for(RemoteExploitCSV files : filesToDownload){
            try{
                Files.delete(Paths.get(files.getFilename()));
            }catch (Exception e){
                System.out.println(e);
            }
        }
    }
}
